---
title: |
  Convolutional \
  Neural Networks
subtitle: "Image Classification"
format:
  revealjs:
    scrollable: true
    navigation-mode: vertical
    controls-layout: bottom-right
    controls-tutorial: true
    incremental: false 
    chalkboard:
      src: chalkboard.json
      storage: chalkboard_pres
      theme: whiteboard
      chalk-width: 4
knitr:
  opts_chunk: 
    echo: true
    eval: true
    message: false
    warnings: false
    comment: "#>" 
    
revealjs-plugins:
  - pointer
  - verticator
  
filters: 
  - reveal-header
  - code-fullscreen
  - reveal-auto-agenda

editor: source
---

# Convolutional Neural Networks

## Convolutional Neural Networks

# Convolutional Layers

# Pooling Layers

# R Code

## MNIST

This is a database of handwritten digits.

We will use to construct neural networks that will classify images.

## Installation of Torch

```{r}
#| echo: true
#| eval: false
install.packages("torch")
install.packages("luz")
install.packages("torchvision")
install.packages("torchdatasets")
install.packages("zeallot")

```

## Torch Packages in R

```{r}
#| echo: true
#| eval: true
# 
library(torch)
library(luz) # high-level interface for torch
library(torchvision) # for datasets and image transformation
library(torchdatasets) # for datasets we are going to use
library(zeallot)
torch_manual_seed(13)

```


## MNIST

```{r}
#| echo: true
#| eval: true
###
train_ds <- mnist_dataset(root = ".", train = TRUE, download = TRUE)
test_ds <- mnist_dataset(root = ".", train = FALSE, download = TRUE)

train_ds[1]
# test_ds[2]

```


  ## Transforming Data

In order to use torch, you must transform the data:
-   tensor
-   flatten
-   tensor divided by the potential values (255)


```{r}
#| echo: true
#| eval: true
 
###
transform <- function(x) {
  x |>
    torch_tensor()  |>
    torch_flatten() |>
    torch_div(255)
}
train_ds <- mnist_dataset(
  root = ".",
  train = TRUE,
  download = TRUE,
  transform = transform
)
test_ds <- mnist_dataset(
  root = ".",
  train = FALSE,
  download = TRUE,
  transform = transform
)

```


## Neural Network Model Set Up

The `nn_module` will begin to setup the neural network. It requires the `initialize` and `forward` functions.

::: fragment
`initialize` is a function that describes the elements of the neural network, the layers.
:::


::: fragment
`nn_linear` will construct a linear framework for the number of inputs, and the number of outputs in the neural network.
:::

::: fragment
`nn_dropout` will randomly "zero" an input elements of a tensor with probability `p`.
:::

::: fragment
`nn_relu` specifies the linear unit function
:::

::: fragment
`forward` describes how the neural network is formatted using the values from the `initialize` function.
:::



```{r}
#| echo: true
#| eval: true

###
modelnn <- nn_module(
  initialize = function() {
    self$linear1 <- nn_linear(in_features = 28*28, out_features = 256)
    self$linear2 <- nn_linear(in_features = 256, out_features = 128)
    self$linear3 <- nn_linear(in_features = 128, out_features = 10)

    self$drop1 <- nn_dropout(p = 0.4)
    self$drop2 <- nn_dropout(p = 0.3)

    self$activation <- nn_relu()
  },
  forward = function(x) {
    x |>
      self$linear1() |>
      self$activation() |>
      self$drop1() |>

      self$linear2() |>
      self$activation() |>
      self$drop2() |>
      self$linear3()
  }
)

## Describe the model:
print(modelnn())

```

## Set Up Neural Network

Tells `luz` (`torch`) how to execute the neural network.

```{r}
#| echo: true
#| eval: false

modelnn <- modelnn |>
  setup(
    loss = nn_cross_entropy_loss(),
    optimizer = optim_rmsprop,
    metrics = list(luz_metric_accuracy())
  )
```

## Fit the Neural Network




```{r}
#| echo: true
#| eval: false

system.time(
   fitted <- modelnn |>
      fit(
        data = train_ds,
        epochs = 5,
        valid_data = 0.2,
        dataloader_options = list(batch_size = 256),
        verbose = FALSE
      )
 )
plot(fitted)
```


## Test Efficiency of Neural Network

```{r}
#| echo: true
#| eval: false


accuracy <- function(pred, truth) {
   mean(pred == truth) }

# gets the true classes from all observations in test_ds.
truth <- sapply(seq_along(test_ds), function(x) test_ds[x][[2]])

fitted |>
  predict(test_ds) |>
  torch_argmax(dim = 2) |> # the predicted class is the one with higher 'logit'.
  as_array() |>  # convert to an R object
  accuracy(truth) # use function created

```