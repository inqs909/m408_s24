{
  "hash": "abf8664ac0fa622f6f3f18fc2151f524",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tree-Based Methods\"\nformat:\n  revealjs:\n    scrollable: true\n    navigation-mode: vertical\n    controls-layout: bottom-right\n    controls-tutorial: true\n    incremental: false \n    chalkboard:\n      src: chalkboard.json\n      storage: chalkboard_pres\n      theme: whiteboard\n      chalk-width: 4\nknitr:\n  opts_chunk: \n    \n    echo: true\n    code-fold: true\n    eval: true\n    message: false\n    warnings: false\n    comment: \"#>\" \nrevealjs-plugins:\n  - pointer\n  - verticator\nfilters: \n  - reveal-header\n  - code-fullscreen\n  - reveal-auto-agenda\neditor_options: \n  chunk_output_type: console\neditor: source\n---\n\n\n# Trees\n\n## Trees\n\nA Statistical tree will partition a region from a set of predictor variables that will predict an outcome of interest.\n\n::: fragment\nTrees will split a region based on a predictors ability to reduce the overall mean squared error.\n:::\n\n::: fragment\nTrees are sometimes preferred to linear models due to the visual explanation of the model.\n:::\n\n## Trees\n\n![](https://www.mathworks.com/help/stats/simpleregressiontree.png){fig-align=\"center\"}\n\n## Fitting a Tree\n\n1.  Start with the entire dataset and define the maximum number of regions or number of observations per region of the tree.\n2.  Calculate the MSE of the dataset.\n3.  For each potential split, calculate the MSE. Choose the split that results in the lowest overall MSE.\n4.  Create a node in the tree with the selected split as the split criterion.\n5.  Repeat steps 2-4 for each subset, stopping if the maximum number of regions has been reached or if the subset size is too small.\n\n# Pruning\n\n## Pruning\n\nPruning is the process that will remove branches from a regression tree in order to prevent overfitting.\n\n::: fragment\nThis will result in a subtree that has high predictive power with no overfitting.\n:::\n\n::: fragment\nDue to the computational burden of pruning, it is recommended to implement *Cost Complexity Pruning.*\n:::\n\n## Cost Complexity Pruning\n\nLet $\\alpha$ be nonnegative tuning parameter that indexes a sequence of trees. Identify the tree that reduces:\n\n$$\n\\sum^{|T|}_{m=1}\\sum_{i:\\ x_i \\in R_m}(y_i-\\hat y_{R_m})^2 +\\alpha|T|\n$$\n\n-   $|T|$: Number of terminal nodes\n\n-   $R_m$: rectangular region containing data\n\n-   $y_i$: observed value\n\n-   $\\hat y_{R_m}$: predicted value in rectangular region.\n\n## Pruning Algorithm\n\n1.  Conduct a fitting algorithm to find the largest tree from the training data. Stop once every region has a small number of observations.\n2.  Apply the cost complexity pruning algorithm to identify the best subset of trees.\n3.  Use a K-fold cross-validation approach to choose the proper $\\alpha$. For each kth fold:\n    1.  Repeat steps 1 and 2.\n    2.  Evaluate the mean squared prediction error as a function of $\\alpha$.\n4.  Average the results for each value of $\\alpha$. Pick the $\\alpha$ that minimizes the error.\n5.  Return the subtree with the selected $\\alpha$ from step 2\n\n# Classification Trees\n\n## Classification Trees\n\nClassification Trees will construct a tree that will classify data based on the region (leaf) you land. The class majority is what is classified.\n\n## Criterion: Gini Index\n\nThe Gini Index is used to determine the error rate in classification trees:\n\n$$\nG = \\sum^K_{k=1} \\hat p_{mk}(1-\\hat p_{mk})\n$$\n\n# Regression Trees\n\n## Regression Trees\n\nRegression trees will construct a tree and predict the value of the outcome based on the average value of the region (leaf).\n\nTrees are constructed by minimizing the residual sums of square.\n\n# Bagging\n\n## Bagging\n\nWhen splitting the data to train and test data sets, the construction of the tree suffers from high variance.\n\n::: fragment\nThis is due to splitting the data in a random way. One training data set will lead to different results from another training data set.\n:::\n\n::: fragment\nTo improve performance, we implement a *Bootstrap Aggregation (Bagging)* technique.\n:::\n\n::: fragment\nBagging will produce a forest of trees to classify a new observation.\n:::\n\n## Bagging Algorithm\n\nGiven a single training data set:\n\n1.  Sample from the data with replacement.\n\n2.  Build a tree from the sampled data:\n\n    $$\n    \\hat f^{*b}(x)\n    $$\n\n3.  Repeat the process B times (B=100)\n\n4.  Compute the final average for all predictions:\n\n    $$\n    \\hat f_{bag}(x)=\\frac{1}{B}\\sum^B_{b=1}\\hat f^{*b}(x)\n    $$\n\n## Classification\n\nTo classify an observation, you can record the classification of each $b$ tree. Then classify an observation by majority rule.\n\n## Variable Importance\n\nWith the implementation of Bagging, you lose interpretability from the original tree due to the forest.\n\nHowever, we can compute which variables reduced the RSS or Gini Index for all the trees. The variables with the largest reduction are considered important.\n\n# Random Forests\n\n## Random Forests\n\nRandom Forests is an extension of Bagging, where a forest is generated from a bootstrap-based approach. However, when making a split, a **random** set of predictors (m\\<p) are chosen for the split, instead of the full set p.\n\n::: fragment\nThis will ensure that trees are unique, uncorrelated.\n:::\n\n::: fragment\nIt ensures that no one predictor will have all the power and lower the variance.\n:::\n\n# Boosting\n\n## Boosting\n\nBoosting is a mechanism where a final tree is built slowly from smaller trees using the residuals.\n\n::: fragment\nThis ensures a tree is built from a slow process and prevents overfitting.\n:::\n\n::: fragment\nThis is done to improve prediction capabilities.\n:::\n\n## Algorithm\n\n1.  Set $\\hat f(x) = 0$ and $r_i = y_i$ for all $i$ in the training set\n\n2.  For $b=1, 2, \\ldots, B$ repeat:\n\n    1.  Fit tree $\\hat f^b$ with $d$ splits ($d+1$ terminal nodes) to the training data $(X,r)$\n\n    2.  Update $\\hat f$\n\n        $$\n        \\hat f(x) \\leftarrow \\hat f(x) + \\lambda\\hat f^b(x)\n        $$\n\n    3.  Update residuals\n\n        $$\n        r_i \\leftarrow r_i - \\lambda\\hat f^{b}(x_i)\n        $$\n\n3.  Output boosted model:\n\n    $$\n    \\hat f(x) = \\sum^B_{b=1} \\lambda \\hat f^b(x)\n    $$\n\n\n# R Code\n\n## Regression Trees\n\n::: panel-tabset\n### R Code\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(tree)\nlibrary(palmerpenguins)\nlibrary(tidyverse)\n\ndf <- penguins |>  drop_na()\ntrain <- sample(1:nrow(df), nrow(df)/2)\ntree_penguin <- penguins |>  tree(body_mass_g ~ flipper_length_mm + bill_length_mm + bill_depth_mm,\n                                  data = _,\n                                  subset = train)\n```\n:::\n\n\n### Plot\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nplot(tree_penguin)\ntext(tree_penguin, pretty = 0)\n```\n\n::: {.cell-output-display}\n![](13a_files/figure-revealjs/unnamed-chunk-2-1.png){width=960}\n:::\n:::\n\n:::\n\n## Classification Trees\n\n::: panel-tabset\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(tree)\nlibrary(palmerpenguins)\nlibrary(tidyverse)\nlibrary(magrittr)\ndf <- penguins |>  drop_na()\ntrain <- sample(1:nrow(df), nrow(df)/2)\ntree_penguin_class <- df |>  tree(species ~ body_mass_g + flipper_length_mm + bill_length_mm + bill_depth_mm, \n                                  data = _,\n                                  subset = train)\n```\n:::\n\n\n### Plot\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nplot(tree_penguin_class)\ntext(tree_penguin_class, pretty = 0)\n```\n\n::: {.cell-output-display}\n![](13a_files/figure-revealjs/unnamed-chunk-4-1.png){width=960}\n:::\n:::\n\n:::\n\n## Pruning\n\n::: panel-tabset\n### Code\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nattach(df)\ntree_penguin_cv <- cv.tree(tree_penguin)\n```\n:::\n\n\n### Summary\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntree_penguin_cv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $size\n#> [1] 6 5 4 3 2 1\n#> \n#> $dev\n#> [1]  24079306  26138047  30484059  30549626  38718249 112604795\n#> \n#> $k\n#> [1]     -Inf  1967559  3060054  3537257  9664694 75001877\n#> \n#> $method\n#> [1] \"deviance\"\n#> \n#> attr(,\"class\")\n#> [1] \"prune\"         \"tree.sequence\"\n```\n\n\n:::\n:::\n\n\n### Plot\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nplot(tree_penguin_cv$size,\n     tree_penguin_cv$dev, type = \"b\")\n```\n\n::: {.cell-output-display}\n![](13a_files/figure-revealjs/unnamed-chunk-7-1.png){width=960}\n:::\n:::\n\n\n### Pruning\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nprune_best <- prune.tree(tree_penguin, best = 7)\nplot(prune_best)\ntext(prune_best, pretty = 0)\n```\n\n::: {.cell-output-display}\n![](13a_files/figure-revealjs/unnamed-chunk-8-1.png){width=960}\n:::\n:::\n\n:::\n\n\n\n## Bagging Regression Trees\n\n::: panel-tabset\n### R Code\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(randomForest)\nlibrary(palmerpenguins)\nlibrary(tidyverse)\nlibrary(magrittr)\n\npenguins <- penguins  |>  drop_na()\ntrain <- sample(1:nrow(penguins), nrow(penguins)/2)\nbag_penguins <- penguins  |>  randomForest(body_mass_g ~ bill_depth_mm + bill_length_mm + flipper_length_mm,\n                                           data = _,\n                                           subset = train, \n                                           mtry = 3, \n                                           importance = T)\n```\n:::\n\n\n### Predictions\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nyhat_bag <- predict(bag_penguins, newdata = penguins[-train , ])\ntest <- penguins[-train , ]$body_mass_g\nplot(yhat_bag, test)\n```\n\n::: {.cell-output-display}\n![](13a_files/figure-revealjs/unnamed-chunk-10-1.png){width=960}\n:::\n:::\n\n:::\n\n## Bagging Classification Trees\n\n::: panel-tabset\n### R Code\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nbag_penguins <- penguins |>  randomForest(species ~ body_mass_g + bill_depth_mm + bill_length_mm + flipper_length_mm, \n                                          data = _,\n                                          subset = train, \n                                          mtry = 4, \n                                          importance = T)\n```\n:::\n\n\n### Prediction\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nyhat_bag <- predict(bag_penguins, newdata = penguins[-train , ])\ntest <- penguins[-train , ]$species\ntable(yhat_bag, test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>            test\n#> yhat_bag    Adelie Chinstrap Gentoo\n#>   Adelie        72         5      0\n#>   Chinstrap      1        30      0\n#>   Gentoo         0         0     59\n```\n\n\n:::\n:::\n\n:::\n\n## Random Forests Regression Trees\n\n::: panel-tabset\n### R Code\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nbag_penguins <- penguins |>  randomForest(body_mass_g ~ bill_depth_mm + bill_length_mm + flipper_length_mm, \n                                          data = _,\n                                          subset = train, \n                                          mtry = 2, \n                                          importance = T)\n```\n:::\n\n\n### Prediction\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nyhat_bag <- predict(bag_penguins, newdata = penguins[-train , ])\ntest <- penguins[-train , ]$body_mass_g\nplot(yhat_bag, test)\n```\n\n::: {.cell-output-display}\n![](13a_files/figure-revealjs/unnamed-chunk-14-1.png){width=960}\n:::\n:::\n\n:::\n\n## Random Forests Classification Trees\n\n::: panel-tabset\n### R Code\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nbag_penguins <- penguins |>  randomForest(species ~ body_mass_g + bill_depth_mm + bill_length_mm + flipper_length_mm, \n                                          data = _,\n                                          subset = train, \n                                          mtry = 2, \n                                          importance = T)\n```\n:::\n\n\n### Prediction\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nyhat_bag <- predict(bag_penguins, newdata = penguins[-train , ])\ntest <- penguins[-train , ]$species\ntable(yhat_bag, test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>            test\n#> yhat_bag    Adelie Chinstrap Gentoo\n#>   Adelie        72         5      0\n#>   Chinstrap      1        30      0\n#>   Gentoo         0         0     59\n```\n\n\n:::\n:::\n\n:::\n\n## Boosting Regression Trees\n\n::: panel-tabset\n### R Code\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(gbm)\nboost_penguin <- gbm(body_mass_g ~ bill_depth_mm + bill_length_mm + flipper_length_mm, \n                     data = penguins[train , ],\n                     distribution = \"gaussian\", \n                     n.trees = 5000,\n                     interaction.depth = 4)\n```\n:::\n\n\n### Prediction\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nyhat_boost <- predict(boost_penguin, \n                      newdata = penguins[-train , ], \n                      n.trees = 5000)\ntest <- penguins[-train , ]$body_mass_g\nplot(yhat_bag, test)\n```\n\n::: {.cell-output-display}\n![](13a_files/figure-revealjs/unnamed-chunk-18-1.png){width=960}\n:::\n:::\n\n:::\n",
    "supporting": [
      "13a_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}