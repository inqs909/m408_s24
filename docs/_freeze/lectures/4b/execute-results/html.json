{
  "hash": "f6020166dc5e7d971fb7af5077440eca",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Intro to Data Manipulation\"\nformat:\n  revealjs:\n    scrollable: true\n    navigation-mode: vertical\n    controls-layout: bottom-right\n    controls-tutorial: true\n    incremental: false \n    chalkboard:\n      src: chalkboard.json\n      storage: chalkboard_pres\n      theme: whiteboard\n      chalk-width: 4\nknitr:\n  opts_chunk: \n    echo: true\n    eval: false\n    message: false\n    comment: \"#>\" \n\neditor: source\n---\n\n\n\n\n## Learning Objectives\n\n-   Anonymous Functions\n\n-   Pipes\n\n-   Scripting\n\n-   Data Manipulation\n\n# Anonymous Functions\n\n## Anonymous Functions\n\nAn anonymous function is a function that is not stored in an R object for the global environment. It can be thought of as a temporary function to complete a task. A common way to used an anonymous function is with an `*apply()` function\\\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nsapply(x, function(x) rnorm(1,x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]  0.9645593  2.4985323  3.6130830  3.4038356  6.6371189  3.9822256\n#>  [7]  7.6365972  8.9805052 12.6891921  7.6383656\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nsapply(x, \\(x) rnorm(1,1,x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]   1.1161187   2.8188918  -1.8337787   3.9964652  -3.8217755  -1.3573966\n#>  [7]  -1.4840088  -0.1488438  19.3957272 -12.3938028\n```\n\n\n:::\n:::\n\n\n## Example\n\nUse an anonymous function to square all the values in the following vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use an anonymous function to calculate the square of each element in a vector\nnumbers <- 1:40\n```\n:::\n\n\n## Example\n\nUse an anonymous function to convert the vector from Fahrenheit to Celsius:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a vector of temperatures in Fahrenheit\ntemperatures_f <- c(32, 68, 104, 50)\n```\n:::\n\n\n$$\nC = \\frac{5(F-32)}{9}\n$$\n\n# Pipes\n\n## Pipes\n\nPipes are used to pass the output from one function and use it as input for another function. The output is piped into the first argument of the next function. There are two main pipes: R's base pipe and Magrittr's pipes. You must download and install the `magrittr` package; and you will need to load it everytime:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr)\n```\n:::\n\n\nAdditionally, pipes can be used to chain functions together.\n\n## `|>`\n\nBefore R 4.1, R did not have a pipe in its main program. The base pipe, `|>`, will pipe the output of the first operation and use it as the input of the first argument of the next function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:40\nx |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 20.5\n```\n\n\n:::\n:::\n\n\n## `%>%`\n\nThe magrittr pipe, `%>%`, operates the same way as `|>`. Below are a couple of examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nx %>%  mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 5.5\n```\n\n\n:::\n\n```{.r .cell-code}\nx %>% sd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3.02765\n```\n\n\n:::\n\n```{.r .cell-code}\nx %>% rnorm(1, .)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2.281058\n```\n\n\n:::\n:::\n\n\n## `%$%`\n\nThe exposition pipe, `%$%`, will expose the named elements, from a list or data frame, to the next function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %$% plot(mpg, hp)\n```\n\n::: {.cell-output-display}\n![](4b_files/figure-revealjs/unnamed-chunk-9-1.png){width=960}\n:::\n:::\n\n\n## `%T>%`\n\nThe Tee pipe, `%T>%`, forward the output in the\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsin_40 <- 1:40 %>% mean %T>% print %>% sin\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 20.5\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(sin_40)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.9968298\n```\n\n\n:::\n:::\n\n\n## `%T>%`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(100) %>% \n  matrix(ncol=2) %>% \n  sin() %T>% \n  plot() %>% \n  colSums()\n```\n:::\n\n\n## Examples\n\nUsing the vector below, find the standard deviation using a pipe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rgamma(100, 1)\nsd(x)\n```\n:::\n\n\n## Examples\n\nChain pipe the previous results into the $sin(x)$.\n\n## Examples\n\nChain pipe the previous results into $e^x$.\n\n## Examples\n\nChain pipe the previous results into $x^2+5x+4$\n\n# Data Projects \n\n## Scripting\n\nThe structure a programming is important to ensure that all methods are executed properly.\n\n## Beginning of Script\n\n\n::: {.cell}\n\n```{.default .cell-code}\n## Todays data \nanalysis_data <- format(Sys.time(),\"%Y-%m-%d-%H-%M\")\n\n## R Packages\nlibrary(tidyverse)\nlibrary(magrittr)\n\n## Functions\nsource(\"fxs.R\")\nRcpp::sourceCpp(\"fxs.cpp\")\n\n## Data\ndf1 <- read_csv(\"file.csv\")\ndf2 <- load(\"file.RData\") %>% get\n```\n:::\n\n\n## Middle of Script\n\n\n::: {.cell}\n\n```{.default .cell-code}\n## Pre Analysis\ndf1_prep <- Prep_data(df1)\ndf2_prep <- Prep_data(df2)\n\n## Analysis\ndf1_analysis <- analyze(df1_prep)\ndf2_analysis <- analyze(df2_prep)\n\n## Post Analysis\ndf1_post <- Prep_post(df1_anlysis)\ndf2_post <- Prep_post(df2_anlysis)\n```\n:::\n\n\n## End of Script\n\n\n::: {.cell}\n\n```{.default .cell-code}\n## Save Results\nres <- list(df1 = list(pre = df1_prep,\n                       analysis = df1_analysis,\n                       post = df1_post),\n            df2 = list(pre = df2_prep,\n                       analysis = df2_analysis,\n                       post = df2_post))\nfile_name <- paste0(\"results_\", analysis_data, \".RData\")\nsave(res, file = file_name)\n```\n:::\n\n\n\n## Keyboard Shortcuts\n\nBelow is a list of recommended keyboard shortcuts:\n\n| Shortcut          | Windows/Linux    | Mac             |\n|-------------------|------------------|-----------------|\n| `%>%`             | Ctrl+Shift+M     | Cmd+Shift+M     |\n| Run Current Line  | Ctrl+Enter       | Cmd+Return      |\n| Run Current Chunk | Ctrl+Shift+Enter | Cmd+Shift+Enter |\n| Knit Document     | Ctrl+Shift+K     | Cmd+Shift+K     |\n| Add Cursor Below  | Ctrl+Alt+Down    | Cmd+Alt+Down    |\n| Comment Line      | Ctrl+Shift+C     | Cmd+Shift+C     |\n\nI recommend modify these keyboard shortcuts in RStudio\n\n| Shortcut | Windows/Linux | Mac         |\n|----------|---------------|-------------|\n| `%in%`   | Ctrl+Shift+I  | Cmd+Shift+I |\n| `%$%`    | Ctrl+Shift+D  | Cmd+Shift+D |\n| `%T>%`   | Ctrl+Shift+T  | Cmd+Shift+T |\n\nNote you will need to install the `extraInserts` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremotes::install_github('konradzdeb/extraInserts')\n```\n:::\n\n\n\n# Data Manipulation\n\n## Data Manipulation\n\n## Tidyverse\n\nTidyverse is a collection of R packages used for data manipulation. The `dplyr` package is known as the grammar of data manipulation with a set\n\n## Verbs\n\n-   `mutate()` adds new variables\n-   `select()` selects variables\n-   `filter()` filters data\n-   `if_else()` conditional function that returns 2 values\n-   `group_by()` a dataset is grouped by factors\n-   `summarise()` provides summaries of data\n\n## Example\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3|4|5|6-9|10|\"}\nlibrary(palmerpenguins)\nsum_stats <- penguins %>% \n  drop_na %>% \n  filter(year==2007) %>% \n  group_by(island) %>% \n  summarise(mean = mean(bill_length_mm),\n            sd = sd(bill_length_mm),\n            median = median(bill_length_mm),\n            n = length(bill_length_mm)) %>% \n  print\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 Ã— 5\n#>   island     mean    sd median     n\n#>   <fct>     <dbl> <dbl>  <dbl> <int>\n#> 1 Biscoe     45.1  4.80   46.1    43\n#> 2 Dream      44.7  5.64   45.4    45\n#> 3 Torgersen  39.0  2.92   39.1    15\n```\n\n\n:::\n:::\n",
    "supporting": [
      "4b_files/figure-revealjs"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}