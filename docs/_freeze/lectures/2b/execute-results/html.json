{
  "hash": "0b1fe13246c4d5c2c76aa4704b189c18",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Control Flow\"\nformat:\n  revealjs:\n    scrollable: true\n    navigation-mode: vertical\n    controls-layout: bottom-right\n    controls-tutorial: true\n    incremental: false \n    chalkboard:\n      src: chalkboard.json\n      storage: chalkboard_pres\n      theme: whiteboard\n      chalk-width: 4\nengine: knitr\nknitr:\n  opts_chunk: \n    echo: true\n    eval: false\n    comment: \"#>\" \n\n\nrevealjs-plugins:\n  - verticator\n  \nfilters: \n  - reveal-header\n  - reveal-auto-agenda\n  - code-fullscreen\n  - webr\n\nwebr: \n  show-startup-message: true\n---\n\n\n\n\n## Learning Objectives\n\n- Nested `for` Loops\n\n# Nested `for` Loops\n\n## Nested `for` Loops\n\nNested `for` loops are `for` loops within another `for` loop. You can stack these loops as much as needed. Just make sure the index is different for each loop. The general format for a loop goes as follow:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in vector_1){\n  for (ii in vector_2){\n    perform task\n  }\n}\n```\n:::\n\n\n## Example\n\nWithout using the `sd()` function, compute the standard deviation for each column of the matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(rnorm(1000), nrow = 10)\n```\n:::\n\n\n$$\ns^2 = \\frac{1}{n-1}\\sum^n_{i=1}(x_i-\\bar x)^2\n$$\n\n\n\n\n# More Examples\n\n## Example\n\nThe `median()` function obtain the median value of a vector. Write code to obtain the median value for any vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(500)\ny <- rnorm(501)\nmedian(x)\nmedian(y)\n```\n:::\n\n\nAnswer:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nwk <- x \npos50 <- (length(wk) + 1) / 2\nswk <- sort(wk)\nif ((length(wk) %% 2) == 0) {\n  val <- (swk[floor(pos50)] + swk[ceiling(pos50)]) / 2\n} else {\n  val <- swk[pos50]\n}\nprint(val)\nmedian(wk)\n\nwk <- y \npos50 <- (length(wk) + 1) / 2\nswk <- sort(wk)\nif ((length(wk) %% 2) == 0) {\n  val <- (swk[floor(pos50)] + swk[ceiling(pos50)]) / 2\n} else {\n  val <- swk[pos50]\n}\nprint(val)\nmedian(wk)\n```\n:::\n\n\n\n\n\n## Example\n\nUsing the code below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(5000)\n```\n:::\n\n\nCreate a new vector containing all the positive values of `x`. The new vector should be less than 5000.\n\nAnswer:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nnn <- length(x)\npos <- c()\nfor (i in 1:nn){\n  if (x[i] > 0) {\n    pos <- c(pos, x[i])\n  }\n}\npos\n```\n:::\n\n\n## Example\n\nCreate a vector reporting the data type of each variable in `ISLR2::BrainCancer` \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ISLR2)\nBrainCancer\n```\n:::\n\n\nAnswer:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nnn <- ncol(BrainCancer)\ny <- c()\nfor (i in 1:nn){\n  y <- c(y, class(BrainCancer[,i]))\n}\n```\n:::\n\n\n\n## Example\n\n$$\nf(x,y) = x^2 + y^2 + \\ln(x+y)\n$$\n\nFind all the values of $f(x,y)$ for every combination of $x \\in \\{1, 8, 13, 25, 42, 67, 95\\}$ and $y \\in \\{6, 12, 18, 52, 61, 79, 83\\}$\n\nStore values in a $7\\times 7$ matrix.\n\nAnswer:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nx <- c(1, 8, 13, 25, 42, 67, 95)\ny <- c(6, 12, 18, 52, 61, 79, 83)\nres <- matrix(nrow = 7, ncol = 7)\ncolnames(res) <- as.character(x)\nrownames(res) <- as.character(y)\n\nfor (i in 1:7){\n  for (ii in 1:7){\n    res[ii,i] <- x[i]^2 + y[ii]^2 + log(x[i] + y[ii])\n  }\n}\nprint(res)\n```\n:::\n\n\n\n\n## Example\n\nFor each column in `mtcars`, take the mean for the even columns, and median for the odd columns. Store the values in a list containing 2 vectors.\n\nAnswer:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nx <- c()\ny <- c()\nnn <- ncol(mtcars)\nfor (i in 1:nn){\n  if (i %% 2 == 0){\n    x <- c(x, mean(mtcars[,i]))\n  } else {\n    y <- c(y, median(mtcars[,i]))\n  }\n}\n\nxy <- list(x,y)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}